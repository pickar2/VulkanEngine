using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Core.Generators.EnumToString;

[Generator]
public class EnumToStringGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context) => context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());

	public void Execute(GeneratorExecutionContext context)
	{
		if (context.SyntaxReceiver is not EnumSyntaxReceiver enumSyntaxReceiver
		    || !enumSyntaxReceiver.Candidates.Any()) return;

		var stringBuilder = new StringBuilder(@"// <auto-generated>

using System;

namespace Core
{
    public static class EnumExtensions
    {");

		foreach (var candidateEnum in enumSyntaxReceiver.Candidates)
		{
			var enumSemanticModel = context.Compilation.GetSemanticModel(candidateEnum.SyntaxTree);
			var symbol = enumSemanticModel.GetDeclaredSymbol(candidateEnum) ??
			             throw new NullReferenceException();
			string symbolName = $"{symbol.ContainingSymbol}.{symbol.Name}";

			string modifier = (Accessibility) Math.Min((int) symbol.DeclaredAccessibility, (int) symbol.ContainingSymbol.DeclaredAccessibility) switch
			{
				Accessibility.Internal => "internal",
				Accessibility.Public => "public",
				_ => null
			};
			if (modifier is null) continue;
			stringBuilder.AppendLine($@"
        {modifier} static string Stringify(this {symbolName} states) => states switch
            {{");
			foreach (var member in candidateEnum.Members)
			{
				// var memberSemanticModel = context.Compilation.GetSemanticModel(member.SyntaxTree);
				// var memberSymbol = memberSemanticModel.GetDeclaredSymbol(member)
				//                    ?? throw new NullReferenceException();
				//var memberAttribute = memberSymbol.GetAttributes()
				//	.FirstOrDefault(attributeData => attributeData.AttributeClass!.Name == nameof(CustomName));
				//string? memberName = memberAttribute?.ConstructorArguments[0].Value?.ToString() ??
				//                     member.Identifier.Value!.ToString();
				string memberName = member.Identifier.Value!.ToString();
				stringBuilder.AppendLine($"\t\t\t\t{symbolName}.{member.Identifier.Value} => \"{memberName}\",");
			}

			stringBuilder.Append(
					"\t\t\t\t_ => throw new ArgumentOutOfRangeException(nameof(states), states, null)")
				.Append(@"
            };");
		}

		stringBuilder.Append("}}");
		context.AddSource("EnumToStringExtensions.g.cs", stringBuilder.ToString());
	}

	public class EnumSyntaxReceiver : ISyntaxReceiver
	{
		public IList<EnumDeclarationSyntax> Candidates { get; } = new List<EnumDeclarationSyntax>();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			if (syntaxNode is EnumDeclarationSyntax enumDeclarationSyntax)
				Candidates.Add(enumDeclarationSyntax);
		}
	}
}
